"""
Estimate nodes and routes/edges risk using risk layer image 
from INARISK http://service1.inarisk.bnpb.go.id:6080/arcgis/rest/services/inaRISK

@author yohanes.gultom@gmail.com
"""

import os
import csv
from PIL import Image, ImageDraw
from typing import Tuple, List

class ImageRiskLookup:
    def __init__(self, img_path: str, samples: List[Tuple]):
        """
        Args:
            img_path (str): path to RGBA image containing green-yellow-red risk layer
            samples (List[Tuple]): tuple containing at least 2 samples of x/y - lan/lot pairs of the risk layer image
        """
        self.img = Image.open(img_path)
        assert len(samples) > 1, 'min 2 samples required'        
        assert len(self.img.getpixel((0, 0))) >= 4, 'must be an RGBA image'        
        x0, y0 = samples[0][0]
        lat0, lon0 = samples[0][1]
        x1, y1 = samples[1][0]
        lat1, lon1 = samples[1][1]
        dx = abs(x1-x0)
        dy = abs(y1-y0)
        dlat = abs(lat1-lat0)
        dlon = abs(lon1-lon0)
        self.lon_per_x = dlon / dx
        self.lat_per_y = dlat / dy
        self.x0 = x0
        self.y0 = y0
        self.lat0 = lat0
        self.lon0 = lon0

    def rgb_to_hsv(self, r: int, g: int, b: int) -> Tuple[float, float, float]:
        """
        Source https://www.w3resource.com/python-exercises/math/python-math-exercise-77.php
        """
        r, g, b = r/255.0, g/255.0, b/255.0
        mx = max(r, g, b)
        mn = min(r, g, b)
        df = mx-mn
        if mx == mn:
            h = 0
        elif mx == r:
            h = (60 * ((g-b)/df) + 360) % 360
        elif mx == g:
            h = (60 * ((b-r)/df) + 120) % 360
        elif mx == b:
            h = (60 * ((r-g)/df) + 240) % 360
        if mx == 0:
            s = 0
        else:
            s = (df/mx)*100
        v = mx*100
        return h, s, v

    def rgba_to_risk(self, rgba: Tuple[int, int, int]) -> float:
        """
        RGBA tuple to risk 0.0 (low) - 0.1 (high)
        """
        r, g, b, a = rgba
        if r == 255 and g == 255 and b == 255:
            # white == no data == no risk
            return 0.0
        h, s, v = self.rgb_to_hsv(r, g, b)
        x = h / 100
        return x-2*(x-0.5)

    def lat_lon_to_risk(self, lat: float, lon: float) -> float:
        """
        Get risk score (0.0 to 1.0) of a given lat/lon
        """
        x = self.x0 + (lon-self.lon0) / self.lon_per_x
        y = self.y0 - (lat-self.lat0) / self.lat_per_y
        max_x, max_y = self.img.size
        if x < 0 or x > max_x or y < 0 or y > max_y:
            print(f'WARNING: out of boundary: {lat}, {lon}')
            print(f'original pixel: {x}, {y}')
            x = min(max(x, 0), max_x - 1)
            y = min(max(y, 0), max_y - 1)
            print(f'adjusted to: {x}, {y}')
        color = self.img.getpixel((x, y))
        return self.rgba_to_risk(color)


def generate_risk_from_pycgr(input_path: str, risk_layer_img_path: str, samples: List[Tuple]):
    """
    Read input pycgr/pycgrc from {input_path},
    get the nodes and routes/edges/networks risk 
    based on given risk_layer_img_path and samples
    write the output to {input_path}_node_risk and {input_path}_risk

    Args:
        input_path (str): path to pycgr file generated by AndGem/OsmToRoadGraph
        risk_layer_img_path (str): path to risk layer image downloaded from INARISK
        samples (List[Tuple]): list of min 2 samples of x/y-lat/lon pairs of the risk_layer_img_path
    """
    lookup = ImageRiskLookup(risk_layer_img_path, samples)
    node_risk_map = {}
    edge_risk_list = []
    total_nodes = None
    total_edges = None
    count_edges = 0
    count_nodes = 0
    print(f'reading {input_path}')
    with open(input_path) as f:
        count = 0
        for line in f:
            if count == 7:
                total_nodes = int(line)
            elif count == 8:
                total_edges = int(line)
            elif count > 8:
                if count_nodes < total_nodes:
                    # start reading nodes
                    node_id, lat, lon = line.split()
                    node_risk = lookup.lat_lon_to_risk(float(lat), float(lon))
                    node_risk_map[node_id] = node_risk
                    count_nodes += 1
                    # print(node_risk)
                else:
                    # edge risk is the highest risk between source and target
                    source_id, target_id, length, street_type, max_speed, bidirectional = line.split()
                    edge_risk = max(node_risk_map[source_id], node_risk_map[target_id])
                    edge_risk_list.append((source_id, target_id, edge_risk, length, max_speed, bidirectional))
                    count_edges += 1
                    # print(edge_risk)
            count += 1

    assert count_nodes == total_nodes
    assert count_edges == total_edges

    # nodes/location risk
    with open(input_path + '_node_risk', 'w+') as f:
        writer = csv.writer(f, delimiter=' ')
        for node_id, node_risk in node_risk_map.items():
            writer.writerow((node_id, node_risk))

    # edges/network risk
    with open(input_path + '_risk', 'w+') as f:
        writer = csv.writer(f, delimiter=' ')
        for source_id, target_id, edge_risk, length, max_speed, bidirectional in edge_risk_list:
            writer.writerow((source_id, target_id, edge_risk, length, max_speed, bidirectional))
